/**
 * RCT Service REST API
 * REST API of `rct-service`.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OARadarIqTrack_point_velocity.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OARadarIqHelpers.h"

namespace OARadarIq {

OARadarIqTrack_point_velocity::OARadarIqTrack_point_velocity(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OARadarIqTrack_point_velocity::OARadarIqTrack_point_velocity() {
    this->initializeModel();
}

OARadarIqTrack_point_velocity::~OARadarIqTrack_point_velocity() {}

void OARadarIqTrack_point_velocity::initializeModel() {

    m_vx_isSet = false;
    m_vx_isValid = false;

    m_vy_isSet = false;
    m_vy_isValid = false;

    m_vz_isSet = false;
    m_vz_isValid = false;

    m_vrad_isSet = false;
    m_vrad_isValid = false;

    m_vfull_isSet = false;
    m_vfull_isValid = false;
}

void OARadarIqTrack_point_velocity::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OARadarIqTrack_point_velocity::fromJsonObject(QJsonObject json) {

    m_vx_isValid = ::OARadarIq::fromJsonValue(m_vx, json[QString("vx")]);
    m_vx_isSet = !json[QString("vx")].isNull() && m_vx_isValid;

    m_vy_isValid = ::OARadarIq::fromJsonValue(m_vy, json[QString("vy")]);
    m_vy_isSet = !json[QString("vy")].isNull() && m_vy_isValid;

    m_vz_isValid = ::OARadarIq::fromJsonValue(m_vz, json[QString("vz")]);
    m_vz_isSet = !json[QString("vz")].isNull() && m_vz_isValid;

    m_vrad_isValid = ::OARadarIq::fromJsonValue(m_vrad, json[QString("vrad")]);
    m_vrad_isSet = !json[QString("vrad")].isNull() && m_vrad_isValid;

    m_vfull_isValid = ::OARadarIq::fromJsonValue(m_vfull, json[QString("vfull")]);
    m_vfull_isSet = !json[QString("vfull")].isNull() && m_vfull_isValid;
}

QString OARadarIqTrack_point_velocity::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OARadarIqTrack_point_velocity::asJsonObject() const {
    QJsonObject obj;
    if (m_vx_isSet) {
        obj.insert(QString("vx"), ::OARadarIq::toJsonValue(m_vx));
    }
    if (m_vy_isSet) {
        obj.insert(QString("vy"), ::OARadarIq::toJsonValue(m_vy));
    }
    if (m_vz_isSet) {
        obj.insert(QString("vz"), ::OARadarIq::toJsonValue(m_vz));
    }
    if (m_vrad_isSet) {
        obj.insert(QString("vrad"), ::OARadarIq::toJsonValue(m_vrad));
    }
    if (m_vfull_isSet) {
        obj.insert(QString("vfull"), ::OARadarIq::toJsonValue(m_vfull));
    }
    return obj;
}

double OARadarIqTrack_point_velocity::getVx() const {
    return m_vx;
}
void OARadarIqTrack_point_velocity::setVx(const double &vx) {
    m_vx = vx;
    m_vx_isSet = true;
}

bool OARadarIqTrack_point_velocity::is_vx_Set() const{
    return m_vx_isSet;
}

bool OARadarIqTrack_point_velocity::is_vx_Valid() const{
    return m_vx_isValid;
}

double OARadarIqTrack_point_velocity::getVy() const {
    return m_vy;
}
void OARadarIqTrack_point_velocity::setVy(const double &vy) {
    m_vy = vy;
    m_vy_isSet = true;
}

bool OARadarIqTrack_point_velocity::is_vy_Set() const{
    return m_vy_isSet;
}

bool OARadarIqTrack_point_velocity::is_vy_Valid() const{
    return m_vy_isValid;
}

double OARadarIqTrack_point_velocity::getVz() const {
    return m_vz;
}
void OARadarIqTrack_point_velocity::setVz(const double &vz) {
    m_vz = vz;
    m_vz_isSet = true;
}

bool OARadarIqTrack_point_velocity::is_vz_Set() const{
    return m_vz_isSet;
}

bool OARadarIqTrack_point_velocity::is_vz_Valid() const{
    return m_vz_isValid;
}

double OARadarIqTrack_point_velocity::getVrad() const {
    return m_vrad;
}
void OARadarIqTrack_point_velocity::setVrad(const double &vrad) {
    m_vrad = vrad;
    m_vrad_isSet = true;
}

bool OARadarIqTrack_point_velocity::is_vrad_Set() const{
    return m_vrad_isSet;
}

bool OARadarIqTrack_point_velocity::is_vrad_Valid() const{
    return m_vrad_isValid;
}

double OARadarIqTrack_point_velocity::getVfull() const {
    return m_vfull;
}
void OARadarIqTrack_point_velocity::setVfull(const double &vfull) {
    m_vfull = vfull;
    m_vfull_isSet = true;
}

bool OARadarIqTrack_point_velocity::is_vfull_Set() const{
    return m_vfull_isSet;
}

bool OARadarIqTrack_point_velocity::is_vfull_Valid() const{
    return m_vfull_isValid;
}

bool OARadarIqTrack_point_velocity::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_vx_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vz_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vrad_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vfull_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OARadarIqTrack_point_velocity::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_vx_isValid && m_vy_isValid && m_vz_isValid && m_vrad_isValid && m_vfull_isValid && true;
}

} // namespace OARadarIq
